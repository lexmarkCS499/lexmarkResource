name: Build, Push Docker Image, and Deploy to Minikube
# This workflow will run on pushes to the dev, staging, and prod branches
on:
  push:
    branches:
      - dev
      - staging
      - prod

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the code from the repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 2: Set up Docker Buildx (for multi-platform builds)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      # Step 3: Set up Minikube Docker environment
      - name: Set up Minikube Docker
        run: |
          eval $(minikube docker-env)  # This ensures that Docker commands use the Minikube Docker daemon

      # Step 4: Build the Docker image (locally in Minikube)
      - name: Build Docker image
        uses: docker/build-push-action@v2
        with:
          context: .
          push: false  # No need to push to DockerHub since we're building locally
          tags: my-app:${{ github.ref_name }}

  deploy:
    needs: build
    runs-on: ubuntu-latest

    steps:
      # Step 5: Checkout the repository again
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 6: Set up kubectl for interacting with the Minikube Kubernetes cluster
      - name: Set up kubectl
        uses: azure/setup-kubectl@v1
        with:
          version: 'latest'

      # Step 7: Log in to ArgoCD
      - name: Log in to ArgoCD
        run: |
          argocd login $(minikube ip):8080 --username admin --password ${{ secrets.ARGOCD_PASSWORD }} --insecure

      # Step 8: Sync the ArgoCD application to deploy the updated image to Minikube
      - name: Sync ArgoCD Application
        run: |
          argocd app sync dev-myapp-argo-application --prune
          argocd app sync staging-myapp-argo-application --prune
          argocd app sync prod-myapp-argo-application --prune
